{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Name-based Pipeline A pipeline doesn't depended on the file-extension (suffix) of filename. All input/output are the NAME, which is actually the filename without suffix The NAME can propagated (become longer name) as task executed on, it's very suitable for versioning and prevent overwritting The filename is read/created based on NAME, so the filenamew listed in directory can naively tell what pipeline has done More details are written in the document, check the link below. -- The draft document in HackMD https://hackmd.io/ogyqCAUZQjaGuw1Mv5BGjw I'll copy it into readme and wiki page in the future Code document https://linnil1.github.io/name-based-pipeline NamePipeAssert Bases: NamePipeError Mostly this is internal error NamePipeDataError Bases: NamePipeError NamePipeError Bases: Exception Basic exception for namepipe module NamePipeNotImplemented Bases: NamePipeError NamePath Bases: str NamePath is represented the NAME which is basically the input/output filename without suffix, but support wildcard (we use {} as wildcard). NamePath is inherited from str, so all str methods can works. logger = logging . getLogger ( __name__ ) class-attribute suffix_key = 'namepipe_catch_suffix' class-attribute template = str ( self ) instance-attribute template_args = () instance-attribute template_kwargs = {} instance-attribute __add__ ( others : Any ) -> NamePath Adding suffix (Also in template) Example input_name = NamePath ( \"a. {} .c\" ) output_name = input_name + \".d\" # = a.{}.c.d __init__ ( name ) We use template and template_args to store the information before construct_name() Note that template_args is empty after we init from a str. In most cases, it doesn't matter. Example The relation of self template look like this self = \"a.00.b.{}.c\" template = \"a.{}.b.{}.c\" template_args = (\"00\", \"{}\") __radd__ ( others : Any ) -> NamePath Adding prefix (Almost same as __add__ ) construct_name ( args : tuple [ Any , ... ], kwargs : dict [ Any , Any ]) -> NamePath Fill the replacement field in name string with *arg or **kwargs . This function will integrate with template, template_args. Example Input data: self = \"a.1.b. {} .c\" self . template = \"a. {} .b. {} .c\" self . template_args = [ \"1\" , \" {} \" ] args = [ \"Q\" ] # from extract_fields() It will merge self.template_args and args self = \"a.1.b.Q.c\" self . template = \"a. {} .b. {} .c\" self . template_args = [ \"1\" , \"Q\" ] copy_others_template ( others : NamePath ) Deep copy the template from another NamePath extract_fields ( name : str | Path ) -> parse . Result Extract the value of replacement fields from the name Example self = \"./data/xxx. {} .oo. {} .mapped\" name = \"./data/xxx.00.oo.a.mapped.bam\" return = Result . fixed = ( \"00\" , \"a\" ) Note that the fields are extract from name string, NOT from template self = \"./data/xxx.00.oo. {} .mapped\" template = \"./data/xxx. {} .oo. {} .mapped\" name = \"./data/xxx.00.oo.a.mapped.bam\" return = Result . fixed = ( \"a\" ,) find_possible_files () -> list [ str ] List all possible files by replacing any replacement fields into * But the built-in * matchs not only single word, it can capture multiple words like xxx.ooo in one * get_fields_name () -> list [ str | int ] Extract all replacement fields from string get_input_names ( depended_pos : list [ str | int ] = []) -> list [ NamePath ] list all names that fit the format Example self = \"./data/xxx.{}.oo.{}.mapped\" return [\"./data/xxx.00.oo.a.mapped\", \"./data/xxx.00.oo.b.mapped\", \"./data/xxx.01.oo.a.mapped\", \"./data/xxx.01.oo.b.mapped\"] With depended_pos self = \"./data/xxx.{}.oo.{}.mapped\" depended_pos = [-1] # the last fields return [\"./data/xxx.00.oo.{}.mapped\", \"./data/xxx.01.oo.{}.mapped\"] Parameters: Name Type Description Default depended_pos list [ str | int ] The position that doesn't treat them as independed fields [] replace_wildcard ( merge_text = '_merge' ) -> NamePath A function that simply self.replace(\".{}\", merge_text) But it takes care about escaped string and template Example print ( input_name ) # \"a.00.c.{}\" print ( input_name . template ) # \"a.{}.c.{}\" output_name = input_name . replace_wildcard ( \"_merge\" ) print ( output_name ) # \"a.00.c_merge\" print ( output_name . template ) # \"a.{}.c_merge\" NameTask Task class that interact with NamePath depended_pos = [] instance-attribute func = func instance-attribute func_args = () instance-attribute func_kwargs = {} instance-attribute input_name = None instance-attribute logger = logging . getLogger ( __name__ ) class-attribute output_name = None instance-attribute __init__ ( func = None ) __repr__ () __rrshift__ ( others ) -> NameTask __rshift__ ( others ) -> NameTask __str__ () copy () -> NameTask Deep copy the instance run ( input_name : NamePath ) -> NameTask Main function to excute the function set_args ( * args , ** kwargs ) -> NameTask Set arguments for main function I recommand the write args in the output_name (make suffix longer, but clear) Note that it will return a new instance because this task may be used mutliple times in the same pipeline which may apply different arguments. Example @nt def func_need_args ( input_name , index ): run ( f \"cat { input_name } .txt > { input_name } .add_ { index } .txt\" ) run ( f \"echo { index } >> { input_name } .add_ { index } .txt\" ) return input_name + f \".add_ { index } \" \"./test. {} \" >> func_need_args . set_args ( index = \"indexname\" ) Return A new NameTask set_depended ( pos : int | list [ int ]) -> NameTask Set depended fields (see NamePath.get_input_names) Example @nt def func_merge_samples ( input_name ): files = [ i + \".txt\" for i in input_name . get_input_names ()] return input_name . replace_wildcard ( \"_merge\" ) \"./test. {} \" >> func_merge_samples . set_depended ( - 1 ) Return A new NameTask nt ( func ) A decorator to create a NameTask() instance Example from namepipe import nt @nt def doSomething ( input_name ): ... return input_name + \".test\" \"\" >> doSomething","title":"Name-based Pipeline"},{"location":"#name-based-pipeline","text":"A pipeline doesn't depended on the file-extension (suffix) of filename. All input/output are the NAME, which is actually the filename without suffix The NAME can propagated (become longer name) as task executed on, it's very suitable for versioning and prevent overwritting The filename is read/created based on NAME, so the filenamew listed in directory can naively tell what pipeline has done More details are written in the document, check the link below. -- The draft document in HackMD https://hackmd.io/ogyqCAUZQjaGuw1Mv5BGjw I'll copy it into readme and wiki page in the future Code document https://linnil1.github.io/name-based-pipeline","title":"Name-based Pipeline"},{"location":"#namepipe.error.NamePipeAssert","text":"Bases: NamePipeError Mostly this is internal error","title":"NamePipeAssert"},{"location":"#namepipe.error.NamePipeDataError","text":"Bases: NamePipeError","title":"NamePipeDataError"},{"location":"#namepipe.error.NamePipeError","text":"Bases: Exception Basic exception for namepipe module","title":"NamePipeError"},{"location":"#namepipe.error.NamePipeNotImplemented","text":"Bases: NamePipeError","title":"NamePipeNotImplemented"},{"location":"#namepipe.path.NamePath","text":"Bases: str NamePath is represented the NAME which is basically the input/output filename without suffix, but support wildcard (we use {} as wildcard). NamePath is inherited from str, so all str methods can works.","title":"NamePath"},{"location":"#namepipe.path.NamePath.logger","text":"","title":"logger"},{"location":"#namepipe.path.NamePath.suffix_key","text":"","title":"suffix_key"},{"location":"#namepipe.path.NamePath.template","text":"","title":"template"},{"location":"#namepipe.path.NamePath.template_args","text":"","title":"template_args"},{"location":"#namepipe.path.NamePath.template_kwargs","text":"","title":"template_kwargs"},{"location":"#namepipe.path.NamePath.__add__","text":"Adding suffix (Also in template) Example input_name = NamePath ( \"a. {} .c\" ) output_name = input_name + \".d\" # = a.{}.c.d","title":"__add__()"},{"location":"#namepipe.path.NamePath.__init__","text":"We use template and template_args to store the information before construct_name() Note that template_args is empty after we init from a str. In most cases, it doesn't matter. Example The relation of self template look like this self = \"a.00.b.{}.c\" template = \"a.{}.b.{}.c\" template_args = (\"00\", \"{}\")","title":"__init__()"},{"location":"#namepipe.path.NamePath.__radd__","text":"Adding prefix (Almost same as __add__ )","title":"__radd__()"},{"location":"#namepipe.path.NamePath.construct_name","text":"Fill the replacement field in name string with *arg or **kwargs . This function will integrate with template, template_args. Example Input data: self = \"a.1.b. {} .c\" self . template = \"a. {} .b. {} .c\" self . template_args = [ \"1\" , \" {} \" ] args = [ \"Q\" ] # from extract_fields() It will merge self.template_args and args self = \"a.1.b.Q.c\" self . template = \"a. {} .b. {} .c\" self . template_args = [ \"1\" , \"Q\" ]","title":"construct_name()"},{"location":"#namepipe.path.NamePath.copy_others_template","text":"Deep copy the template from another NamePath","title":"copy_others_template()"},{"location":"#namepipe.path.NamePath.extract_fields","text":"Extract the value of replacement fields from the name Example self = \"./data/xxx. {} .oo. {} .mapped\" name = \"./data/xxx.00.oo.a.mapped.bam\" return = Result . fixed = ( \"00\" , \"a\" ) Note that the fields are extract from name string, NOT from template self = \"./data/xxx.00.oo. {} .mapped\" template = \"./data/xxx. {} .oo. {} .mapped\" name = \"./data/xxx.00.oo.a.mapped.bam\" return = Result . fixed = ( \"a\" ,)","title":"extract_fields()"},{"location":"#namepipe.path.NamePath.find_possible_files","text":"List all possible files by replacing any replacement fields into * But the built-in * matchs not only single word, it can capture multiple words like xxx.ooo in one *","title":"find_possible_files()"},{"location":"#namepipe.path.NamePath.get_fields_name","text":"Extract all replacement fields from string","title":"get_fields_name()"},{"location":"#namepipe.path.NamePath.get_input_names","text":"list all names that fit the format Example self = \"./data/xxx.{}.oo.{}.mapped\" return [\"./data/xxx.00.oo.a.mapped\", \"./data/xxx.00.oo.b.mapped\", \"./data/xxx.01.oo.a.mapped\", \"./data/xxx.01.oo.b.mapped\"] With depended_pos self = \"./data/xxx.{}.oo.{}.mapped\" depended_pos = [-1] # the last fields return [\"./data/xxx.00.oo.{}.mapped\", \"./data/xxx.01.oo.{}.mapped\"] Parameters: Name Type Description Default depended_pos list [ str | int ] The position that doesn't treat them as independed fields []","title":"get_input_names()"},{"location":"#namepipe.path.NamePath.replace_wildcard","text":"A function that simply self.replace(\".{}\", merge_text) But it takes care about escaped string and template Example print ( input_name ) # \"a.00.c.{}\" print ( input_name . template ) # \"a.{}.c.{}\" output_name = input_name . replace_wildcard ( \"_merge\" ) print ( output_name ) # \"a.00.c_merge\" print ( output_name . template ) # \"a.{}.c_merge\"","title":"replace_wildcard()"},{"location":"#namepipe.task.NameTask","text":"Task class that interact with NamePath","title":"NameTask"},{"location":"#namepipe.task.NameTask.depended_pos","text":"","title":"depended_pos"},{"location":"#namepipe.task.NameTask.func","text":"","title":"func"},{"location":"#namepipe.task.NameTask.func_args","text":"","title":"func_args"},{"location":"#namepipe.task.NameTask.func_kwargs","text":"","title":"func_kwargs"},{"location":"#namepipe.task.NameTask.input_name","text":"","title":"input_name"},{"location":"#namepipe.task.NameTask.logger","text":"","title":"logger"},{"location":"#namepipe.task.NameTask.output_name","text":"","title":"output_name"},{"location":"#namepipe.task.NameTask.__init__","text":"","title":"__init__()"},{"location":"#namepipe.task.NameTask.__repr__","text":"","title":"__repr__()"},{"location":"#namepipe.task.NameTask.__rrshift__","text":"","title":"__rrshift__()"},{"location":"#namepipe.task.NameTask.__rshift__","text":"","title":"__rshift__()"},{"location":"#namepipe.task.NameTask.__str__","text":"","title":"__str__()"},{"location":"#namepipe.task.NameTask.copy","text":"Deep copy the instance","title":"copy()"},{"location":"#namepipe.task.NameTask.run","text":"Main function to excute the function","title":"run()"},{"location":"#namepipe.task.NameTask.set_args","text":"Set arguments for main function I recommand the write args in the output_name (make suffix longer, but clear) Note that it will return a new instance because this task may be used mutliple times in the same pipeline which may apply different arguments. Example @nt def func_need_args ( input_name , index ): run ( f \"cat { input_name } .txt > { input_name } .add_ { index } .txt\" ) run ( f \"echo { index } >> { input_name } .add_ { index } .txt\" ) return input_name + f \".add_ { index } \" \"./test. {} \" >> func_need_args . set_args ( index = \"indexname\" ) Return A new NameTask","title":"set_args()"},{"location":"#namepipe.task.NameTask.set_depended","text":"Set depended fields (see NamePath.get_input_names) Example @nt def func_merge_samples ( input_name ): files = [ i + \".txt\" for i in input_name . get_input_names ()] return input_name . replace_wildcard ( \"_merge\" ) \"./test. {} \" >> func_merge_samples . set_depended ( - 1 ) Return A new NameTask","title":"set_depended()"},{"location":"#namepipe.task.nt","text":"A decorator to create a NameTask() instance Example from namepipe import nt @nt def doSomething ( input_name ): ... return input_name + \".test\" \"\" >> doSomething","title":"nt()"}]}